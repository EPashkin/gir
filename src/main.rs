#![cfg_attr(feature = "cargo-clippy", allow(match_same_arms))]
#![cfg_attr(feature = "cargo-clippy", allow(let_and_return))]
#![cfg_attr(feature = "cargo-clippy", allow(too_many_arguments))]

extern crate case;
extern crate docopt;
extern crate env_logger;
#[macro_use]
extern crate error_chain;
extern crate git2;
extern crate hprof;
#[macro_use]
extern crate lazy_static;
#[macro_use]
extern crate log;
#[macro_use]
extern crate serde_derive;
extern crate serde;
extern crate regex;
extern crate stripper_lib;
extern crate toml;
extern crate xml;

use std::cell::RefCell;

use config::WorkMode;
use env::Env;
use library::Library;
use hprof::Profiler;

//generated by build.rs
mod gir_version;

mod analysis;
mod chunk;
mod codegen;
mod config;
mod consts;
mod custom_type_glib_priority;
mod env;
mod file_saver;
mod git;
mod library;
mod library_postprocessing;
mod library_preprocessing;
mod nameutil;
mod parser;
mod traits;
mod update_version;
mod version;
mod visitors;
mod writer;
mod xmlparser;

use self::config::error::*;

#[cfg_attr(test, allow(dead_code))]
fn main() {
    if let Err(ref e) = do_main() {
        println!("{}", e);

        for e in e.iter().skip(1) {
            println!("caused by: {}", e);
        }

        ::std::process::exit(1);
    }
}

fn do_main() -> Result<()> {
    if std::env::var_os("RUST_LOG").is_none() {
        std::env::set_var("RUST_LOG", "gir=warn");
    }
    env_logger::init();

    let mut cfg = match config::Config::new() {
        Ok(cfg) => cfg,
        Err(Error(ErrorKind::CommandLine(ref err), _)) => {
            // Fatal errors processed in same branch
            // to prevent repeat message in "caused by:"
            if err.fatal() {
                println!("error: {}", err);
            } else {
                println!("{}", err);
            }
            return Ok(());
        }
        Err(err) => return Err(err),
    };

    let statistics = Profiler::new("Gir");
    statistics.start_frame();

    let watcher_total = statistics.enter("Total");

    let mut library;

    {
        let _watcher = statistics.enter("Loading");

        library = Library::new(&cfg.library_name);
        try!(library.read_file(&cfg.girs_dir, &cfg.library_full_name()));
    }

    {
        let _watcher = statistics.enter("Preprocessing");
        library.preprocessing(cfg.work_mode);
    }

    {
        let _watcher = statistics.enter("Update library by config");
        update_version::apply_config(&mut library, &cfg);
    }

    {
        let _watcher = statistics.enter("Postprocessing");
        library.postprocessing();
    }

    {
        let _watcher = statistics.enter("Resolving type ids");
        cfg.resolve_type_ids(&library);
    }

    {
        let _watcher = statistics.enter("Checking versions");
        update_version::check_function_real_version(&mut library);
    }

    let mut env;

    {
        let _watcher = statistics.enter("Namespace/symbol/class analysis");

        let namespaces = analysis::namespaces::run(&library);
        let symbols = analysis::symbols::run(&library, &namespaces);
        let class_hierarchy = analysis::class_hierarchy::run(&library);

        env = Env {
            library: library,
            config: cfg,
            namespaces: namespaces,
            symbols: RefCell::new(symbols),
            class_hierarchy: class_hierarchy,
            analysis: Default::default(),
        };
    }

    if env.config.work_mode != WorkMode::Sys {
        let _watcher = statistics.enter("Analysing");
        analysis::run(&mut env);
    }

    if env.config.work_mode != WorkMode::DisplayNotBound {
        let _watcher = statistics.enter("Generating");
        codegen::generate(&env);
    }

    drop(watcher_total);
    statistics.end_frame();

    if env.config.show_statistics {
        statistics.print_timing();
    }
    if env.config.work_mode == WorkMode::DisplayNotBound {
        env.library.show_non_bound_types(&env);
    }

    Ok(())
}
